# 动态规划 (DP) 最简单解释
🔍 原理：记住答案，避免重复计算
核心思想：把大问题拆成小问题，把小问题的答案存起来，下次直接用，不用重新算。 记忆化搜索 = DP
有重叠子问题：同一小问题要算很多次
最优子结构：大问题的最优解包含小问题的最优解
例子：斐波那契数列
递归：f(5) = f(4) + f(3)，f(4) = f(3) + f(2)...会重复算很多次
DP：f(1)=1, f(2)=1，然后 f(3)=f(2)+f(1)=2，f(4)=f(3)+f(2)=3...每次只算一次
## 🎯 使用场景
适合用DP的问题：
求最大/最小/个数（最优化问题）
能拆成子问题（原问题依赖于子问题）
子问题会重复（不记录会重复计算）
有最优子结构（大问题最优解由小问题最优解组成）
典型问题：爬楼梯、背包问题、最长公共子序列、编辑距离
## 📊 三种主要类型
1️⃣ 线性DP
    特点：状态排成一条线，按顺序计算 常见形式：dp[i] = 考虑前i个物品的最优值 经典问题：
    爬楼梯：dp[i] = dp[i-1] + dp[i-2]
    最大子序列和：dp[i] = max(dp[i-1] + nums[i], nums[i])
    打家劫舍：dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    口诀：一维数组，从左到右
    强化练习（LeetCode，高频且实用，建议顺序练习）：
    - 70（Climbing Stairs / 爬楼梯）✅
    - 53（Maximum Subarray / 最大子序和）✅
    - 198（House Robber / 打家劫舍）✅

2️⃣ 背包DP
    特点：在容量限制下，选择物品优化价值 状态：dp[i][w] = 考虑前i个物品，容量为w时的最大价值 常见类型：
    ![背包分类](./背包.png)
    - 0-1背包：每样只能选0个或1个
    - 完全背包：每样可以选无限次
    - 多重背包：每样有限个
    - 分组背包：
    经典问题：
    0-1背包：dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])
    零钱兑换：用最少硬币凑成金额
    口诀：二维数组，容量遍历
    强化练习（LeetCode，高频且实用，覆盖 0-1 与完全背包思维）：
    - 416（Partition Equal Subset Sum / 分割等和子集）【0-1 背包】
    - 322（Coin Change / 零钱兑换）【完全背包，最少硬币数】
    - 518（Coin Change II / 零钱兑换 II）【完全背包，组合数】

    0-1背包
        01背包问题理论基础二维dp数组
        01背包问题理论基础一维dp数组（滚动数组）
        416.分割等和子集
        1049.最后一块石头的重量 II
        494.目标和
        474.一和零
    完全背包
        动态规划：关于完全背包，你该了解这些！
        518. 零钱兑换 II
        0377.组合总和Ⅳ.
        70.爬楼梯进阶版
        322. 零钱兑换
        279.完全平方数
        139.单词拆分

3️⃣ 区间DP
    特点：问题定义在区间[l, r]上，枚举分割点 状态：dp[l][r] = 区间[l, r]的最优值 经典问题：
    矩阵链乘法：dp[l][r] = min(dp[l][k] + dp[k+1][r] + cost)
    xxx - 括号匹配
    312 - 戳气球 (Hard)
    516 - 最长回文子序列 (Medium)
    口诀：区间长度从小到大，枚举分割点
    强化练习（LeetCode，高频且经典的区间DP）：
    - 312（Burst Balloons / 戳气球）
    - 1039（Minimum Score Triangulation of Polygon / 多边形三角剖分最低得分）
    - 1547（Minimum Cost to Cut a Stick / 切棍子的最小成本）

## 💡 解题套路
4步法：
定义状态：dp[x] 或 dp[i][j] 是什么？
找状态转移：怎么从已知状态得到新状态？
初始化：dp的初始值是什么？
遍历顺序：按什么顺序计算dp？
记忆口诀：
线性DP：一维刷表
背包DP：容量从大到小
区间DP：长度从小到大
🔑 最关键的理解
DP不是算法，是思想：
把递归写成迭代
用空间换时间
核心是状态转移方程

记住：**所有DP问题本质都是递归问题，只是把递归树重叠的部分合并了！**