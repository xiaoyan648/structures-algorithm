# structures-algorithm
数据结构与算法


## 完整计划

# 高频算法四阶段推进计划

这份清单严格适配你的时间节奏（工作日1-2h/天、周末集中安排），聚焦面试高频算法，按“基础入门→专项突破→混合强化→模拟冲刺”四阶段推进，可直接落地执行。



### 第一阶段：基础入门（第1-4周）—— 覆盖核心类型，搭建知识框架



核心目标：掌握所有高频算法的基础原理、经典模板，能独立做简单题，周末集中复盘巩固。



| 周次  | 工作日重点（每天1个小模块）                                      | 周末任务（集中6-8h）                                                        | 必刷基础题（LeetCode）                                                                    |
| ----- | ---------------------------------------------------------------- | --------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| 第1周 | 数组（遍历、二分、双指针）+ 字符串（拼接、匹配、替换）           | 复盘本周知识点，整理2类题的解题模板；补刷未完成的简单题，再额外刷2道中等题  | Easy：26（去重）、125（回文串）、344（反转字符串）；Medium：15（三数之和）                |
| 第2周 | 链表（单链表操作、双指针、环判断）+ 哈希表（存储、查找、计数）   | 复盘模板（链表遍历/反转、哈希表常用场景）；集中刷5-6道中等题，整理错题      | Easy：206（反转链表）、1（两数之和）；Medium：141（环形链表II）、49（字母异位词分组）     |
| 第3周 | 树/二叉树（遍历、递归、层次遍历）+ 栈/队列（基础操作、应用场景） | 总结二叉树前中后序遍历（递归+迭代）模板；刷树和栈队列的中等题，强化递归思路 | Easy：144（前序遍历）、225（用栈实现队列）；Medium：102（层次遍历）、94（中序遍历迭代版） |
| 第4周 | 贪心算法（核心思想、经典场景）+ 简单动态规划（单状态DP）         | 复盘贪心vsDP的区别；集中刷4-5道题，整理DP状态转移的基础思路                 | Easy：55（跳跃游戏）、70（爬楼梯）；Medium：122（买卖股票II）、455（分发饼干）            |


### 第二阶段：专项突破（第5-8周）—— 攻克高频中等题，强化解题手感



核心目标：聚焦面试必考重点类型，批量刷题+归纳套路，提升中等题的解题速度和正确率。



| 周次  | 专项主题                 | 工作日任务（每天1-2h）                                                  | 周末任务（集中8-10h）                                                        | 必刷高频题                                                                     |
| ----- | ------------------------ | ----------------------------------------------------------------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| 第5周 | 动态规划（DP）专项       | 每天学1个DP子类型（线性DP、背包DP、区间DP），刷2道对应中等题            | 集中刷8-10道DP中等题，整理3类DP的状态转移模板；复盘错题，总结“什么时候用DP”  | Medium：322（零钱兑换）、62（不同路径）、1143（最长公共子序列）                |
| 第6周 | 数组/字符串进阶专项      | 每天聚焦1个进阶考点（滑动窗口、前缀和、字符串匹配KMP），刷2道题         | 批量刷滑动窗口和前缀和中等题（6-8道）；总结滑动窗口适用场景（子串问题）      | Medium：3（无重复字符最长子串）、560（和为K的子数组）、209（长度最小的子数组） |
| 第7周 | 树/二叉搜索树（BST）专项 | 每天学BST特性、平衡树基础，刷2道树的中等/难题                           | 集中刷树的高频题（7-9道），包括二叉树构造、路径问题；总结递归/迭代的最优写法 | Medium：98（验证BST）、105（从前序与中序遍历构造二叉树）、437（路径总和III）   |
| 第8周 | 回溯+图论专项            | 工作日学回溯（组合、排列、子集）和图的基础（遍历、最短路径），每天2道题 | 刷回溯中等题（5-6道）+ 图的基础题（3-4道）；总结回溯的“剪枝”技巧             | Medium：77（组合）、46（全排列）、207（课程表）、797（所有可能的路径）         |


### 第三阶段：混合强化（第9-10周）—— 打乱类型刷题，提升应变能力



核心目标：打破类型局限，适应面试“随机出题”场景，强化限时解题能力。



| 周次   | 工作日任务                                                 | 周末任务                                                                   | 训练重点                                 |
| ------ | ---------------------------------------------------------- | -------------------------------------------------------------------------- | ---------------------------------------- |
| 第9周  | 每天随机刷2-3道中等题（覆盖之前所有类型），限时30分钟/题   | 集中进行1次“半天刷题”（10道中等题，限时2小时）；复盘错题，补充薄弱类型     | 提升读题速度和思路反应，避免“只会一类题” |
| 第10周 | 每天刷1道中等题+1道简单题，或1道难题（选做），记录解题时间 | 整理“高频错题本”，按类型归类（比如DP类错题、滑动窗口类错题）；重刷所有错题 | 巩固薄弱点，确保同类题不再出错           |


### 第四阶段：模拟冲刺（第11-12周）—— 贴合面试场景，实战演练



核心目标：模拟真实面试流程，适应限时压力，查漏补缺。



| 周次   | 工作日任务                                                                 | 周末任务                                                                | 面试适配                               |
| ------ | -------------------------------------------------------------------------- | ----------------------------------------------------------------------- | -------------------------------------- |
| 第11周 | 每天限时刷3道中等题（1.5小时内完成）；看面试常考算法的最优解思路           | 进行2轮模拟面试（每轮1小时，3道题，按真实面试流程）；复盘答题节奏和表达 | 训练“边想边说”的能力，避免只会写不会讲 |
| 第12周 | 重刷高频错题+经典难题（各5-8道）；背诵核心模板（比如DP状态转移、回溯模板） | 最后1轮模拟面试；整理“面试必备算法清单”，快速过一遍所有核心知识点       | 保持解题手感，自信应对面试             |


### 关键执行提醒



- 工作日优先“学基础+少量刷题”，不贪多，重点在“理解+动手敲代码”，避免熬夜影响工作。

- 周末必须留2-3h复盘，错题本是核心，要记录“错因（思路错/代码bug/超时）+ 最优解 + 同类题链接”。

- 刷题平台首选LeetCode，按“简单→中等→难题”梯度来，中等题是面试核心（占比70%以上），难题可选择性放弃。



结尾交付物提议：要不要我帮你整理一份**高频算法解题模板手册**，包含每个类型的核心思路、代码模板（Python/Java可选）和易错点，直接节省你总结的时间？
> （注：文档部分内容可能由 AI 生成）

## 贪心和DP

## 数据结构

### 数组

### 栈

### 树

### 图

## 真题

### xhs

### bytedance

### xiecheng


## 工程

工程中最常用的算法与数据结构实战应用
📊 业务场景常用数据结构
1. 缓存类
数据结构	实际应用	典型场景
LRU Cache	Redis LRU、浏览器缓存	最近最少使用淘汰
LFU Cache	Redis LFU	最不经常使用淘汰
哈希表 + 链表	LinkedHashMap	缓存实现
布隆过滤器	缓存穿透防护、黑名单过滤	快速判断"不存在"
2. 存储索引
数据结构	实际应用	典型场景
B+树	MySQL InnoDB索引	范围查询、排序
LSM树	LevelDB、RocksDB	写多读少场景
跳表	Redis ZSet	有序集合、排行榜
前缀树(Trie)	自动补全、敏感词过滤	前缀匹配
3. 限流与流量控制
算法	实际应用	典型场景
令牌桶	网关限流、API限流	突发流量控制
漏桶	网络流量整形	均匀流量输出
滑动窗口	滑动时间窗口统计	实时统计、限流
漏斗算法	登录防刷、下单限流	流量过滤
⏰ 时间轮 (Timing Wheel)
核心应用场景
1. 定时任务调度

// Kafka定时任务实现
type TimingWheel struct {
    tickMs      int64        // 毫秒间隔
    wheelSize   int          // 时间轮大小
    startTime   int64        // 起始时间
    buckets     []*Bucket    // 时间槽
    currentTime int64        // 当前时间
}

type Job struct {
    delay    int64  // 延迟时间
    key      string // 业务key
    callback func() // 回调函数
}

// 应用场景：
// - Kafka消息延迟投递
// - Redis过期键删除
// - 网关超时处理
// - 订单超时取消
// - 心跳检测
2. 实际工程案例
Kafka：延迟消息、事务超时
Netty：连接超时管理
xxl-job：分布式定时任务
Elasticsearch：定时刷新索引
🤖 RAG (检索增强生成) 编排
核心算法流程

// 简化RAG流程
type RAGPipeline struct {
    documents   []Document     // 文档库
    vectorDB    VectorDB       // 向量数据库
    llm         LLM            // 大语言模型
    promptMgr   PromptManager  // 提示词管理
}

func (r *RAGPipeline) Query(question string) string {
    // 1. 向量化查询
    queryVector := r.vectorDB.Embed(question)
    
    // 2. 相似度检索 (常用算法：余弦相似度)
    topDocs := r.vectorDB.Search(queryVector, topK=5)
    
    // 3. 上下文构建
    context := r.buildContext(topDocs)
    
    // 4. 提示词编排
    prompt := r.promptMgr.BuildPrompt(question, context)
    
    // 5. LLM生成
    return r.llm.Generate(prompt)
}
核心算法与数据结构
算法	作用	实际应用
向量嵌入	文本→向量	Word2Vec, BERT, OpenAI Embeddings
相似度计算	余弦相似度、欧氏距离	FAISS, Milvus
图遍历	RAG链路编排	DAG调度、A*搜索
Top-K检索	K近邻搜索	HNSW, IVF
滑动窗口	上下文窗口管理	Token窗口控制
🎯 推荐系统算法
1. 协同过滤 (Collaborative Filtering)

// 用户相似度计算
func UserSimilarity(userItems map[int][]int) map[int]map[int]float64 {
    // 算法：余弦相似度
    // sim(u,v) = |N(u) ∩ N(v)| / sqrt(|N(u)| * |N(v)|)
    
    // 应用场景：
    // - 电商推荐
    // - 视频推荐
    // - 音乐推荐
}
2. 矩阵分解 (Matrix Factorization)

// 经典ALS算法
func ALS(userItemMatrix [][]float64) (U, V [][]float64) {
    // R ≈ U * V^T
    // U: 用户隐语义矩阵
    // V: 物品隐语义矩阵
    
    // 应用场景：
    // - Netflix推荐
    // - 广告CTR预估
}
3. 深度学习推荐
模型	特点	应用
Wide&Deep	记忆+泛化	Google Play推荐
DeepFM	自动特征交叉	CTR预估
DIN	注意力机制	阿里巴巴广告推荐
Graph Neural Network	图神经网络	社交推荐
🔗 分布式算法
1. 一致性哈希 (Consistent Hashing)

type ConsistentHash struct {
    nodes     []string
    hashRing  map[uint32]string  // 哈希环
    virtualNodes int            // 虚拟节点数
}

func (c *ConsistentHash) Get(key string) string {
    hash := c.hash(key)
    node := c.getNode(hash)
    return node
}

// 应用场景：
// - Redis Cluster分片
// - Cassandra数据分布
// - 负载均衡
// - CDN内容分发
2. Raft/Paxos (分布式一致性)

type RaftNode struct {
    state     NodeState  // Follower, Candidate, Leader
    log       []LogEntry // 日志
    commitIdx int        // 已提交位置
}

// 应用场景：
// - etcd一致性存储
// - Consul服务发现
// - Kafka Controller选举
// - TiKV分布式事务
📈 实时计算算法
1. 滑动窗口统计

type SlidingWindowCounter struct {
    windowSize  int           // 窗口大小
    data        []int64       // 环形缓冲区
    currentIdx  int           // 当前索引
    currentSum  int64         // 当前窗口和
}

// 应用场景：
// - 实时统计API调用量
// - 用户行为分析
// - 监控指标计算
2. HyperLogLog (基数估算)

type HyperLogLog struct {
    registers []uint8  // 寄存器数组
    m         int      // 桶数
}

// 应用场景：
// - UV统计 (DAU/MAU)
// - Redis PFADD
// - 数据库去重基数估算
3. Count-Min Sketch (频次统计)

type CountMinSketch struct {
    depth  int         // 哈希函数数量
    width  int         // 数组宽度
    cms    [][]int64   // 计数数组
}

// 应用场景：
// - Top-K热词统计
// - 流量去重
// - 频率估算
🎨 其他高频应用
1. 搜索排序
算法	应用场景
BM25	文本相关性排序
TF-IDF	关键词权重计算
PageRank	Google网页排序
HNSW	向量搜索
2. 图算法
算法	应用场景
Dijkstra	路径规划、导航
A*	游戏寻路、AI导航
最小生成树	网络拓扑设计
拓扑排序	依赖管理、任务调度
3. 机器学习
算法	应用场景
LR (逻辑回归)	CTR预估
GBDT	推荐、排序
K-Means	用户聚类
决策树	规则引擎、风控
💡 总结：业务优先级
最常用TOP 10：
哈希表 - 缓存、唯一性检查
B+树 - 数据库索引
LRU/LFU - 缓存淘汰
布隆过滤器 - 去重、穿透防护
一致性哈希 - 分布式存储
时间轮 - 定时任务
滑动窗口 - 实时统计
令牌桶 - 限流
LR/GBDT - 推荐、CTR
向量检索 - 语义搜索、RAG
实际工作中：
80%问题用基础数据结构解决（数组、链表、哈希表、堆）
15%需要高级算法（DP、图算法、搜索）
5%需要机器学习/深度学习
需要我详细讲哪个场景的算法实现？