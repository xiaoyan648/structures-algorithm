# 动态规划 (DP) 最简单解释
🔍 原理：记住答案，避免重复计算
核心思想：把大问题拆成小问题，把小问题的答案存起来，下次直接用，不用重新算。 记忆化搜索 = DP
有重叠子问题：同一小问题要算很多次
最优子结构：大问题的最优解包含小问题的最优解
例子：斐波那契数列
递归：f(5) = f(4) + f(3)，f(4) = f(3) + f(2)...会重复算很多次
DP：f(1)=1, f(2)=1，然后 f(3)=f(2)+f(1)=2，f(4)=f(3)+f(2)=3...每次只算一次
## 🎯 使用场景
适合用DP的问题：
求最大/最小/个数（最优化问题）
能拆成子问题（原问题依赖于子问题）
子问题会重复（不记录会重复计算）
有最优子结构（大问题最优解由小问题最优解组成）
典型问题：爬楼梯、背包问题、最长公共子序列、编辑距离
## 📊 三种主要类型
1️⃣ 线性DP
    特点：状态排成一条线，按顺序计算 常见形式：dp[i] = 考虑前i个物品的最优值 经典问题：
    爬楼梯：dp[i] = dp[i-1] + dp[i-2]
    最大子序列和：dp[i] = max(dp[i-1] + nums[i], nums[i])
    打家劫舍：dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    口诀：一维数组，从左到右
2️⃣ 背包DP
    特点：在容量限制下，选择物品优化价值 状态：dp[i][w] = 考虑前i个物品，容量为w时的最大价值 常见类型：
    0-1背包：每样只能选0个或1个
    完全背包：每样可以选无限次
    多重背包：每样有限个
    经典问题：
    0-1背包：dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])
    零钱兑换：用最少硬币凑成金额
    口诀：二维数组，容量遍历
3️⃣ 区间DP
    特点：问题定义在区间[l, r]上，枚举分割点 状态：dp[l][r] = 区间[l, r]的最优值 经典问题：
    矩阵链乘法：dp[l][r] = min(dp[l][k] + dp[k+1][r] + cost)
    括号匹配、戳气球、石子合并
    口诀：区间长度从小到大，枚举分割点
## 💡 解题套路
4步法：
定义状态：dp[x] 或 dp[i][j] 是什么？
找状态转移：怎么从已知状态得到新状态？
初始化：dp的初始值是什么？
遍历顺序：按什么顺序计算dp？
记忆口诀：
线性DP：一维刷表
背包DP：容量从大到小
区间DP：长度从小到大
🔑 最关键的理解
DP不是算法，是思想：
把递归写成迭代
用空间换时间
核心是状态转移方程
记住：所有DP问题本质都是递归问题，只是把递归树重叠的部分合并了！